import Sofa
import SofaRuntime
import numpy as np
import os
from splib3.numerics import Quat, Vec3
from splib3.animation import AnimationManager
from scipy.spatial.transform import Rotation as R

import rospy
import rospkg
import tf
from mag_msgs.msg import FieldStamped, CurrentsStamped
from std_msgs.msg import Float32
from mag_manip import mag_manip
from visualization_msgs.msg import MarkerArray
from geometry_msgs.msg import Pose, Wrench

from sofa_beam_rviz_markers_utils import *


class CatheterControl(Sofa.Core.Controller):

    def __init__(self, *args, **kwargs):
        # These are needed (and the normal way to override from a python class)
        Sofa.Core.Controller.__init__(self, *args, **kwargs)

        # communicate with ROS
        rospy.init_node('sofa_valid', anonymous=True, log_level=rospy.INFO)

        self.MO = kwargs["MechObj"]
        self.CFF = kwargs["ConstantForceField"]
        self.CFF_visu = kwargs["CCF_visu_mag_field"]
        self.IRC = kwargs["InterventionalRadiologyController"]
        self.mag_index = kwargs['mag_index']
        self.name = 'CatheterControl'
        self.length_init = kwargs['length_init']
        self.tube_rig_pos = kwargs['tube_rig_pos']
        self.T_sim_mns = kwargs['T_sim_mns']
        self.T_2dmodel_sim = kwargs['T_2dmodel_sim']
        self.MO_visu_rviz = kwargs["MO_visu_rviz"]
        self.mag_index_visu = kwargs["mag_index_visu"]
        self.mag_len = kwargs["mag_len"]
        self.outer_diam_tube = kwargs["outer_diam_tube"]
        self.inner_diam_tube = kwargs["inner_diam_tube"]
        self.outer_diam_mag = kwargs["outer_diam_mag"]
        self.inner_diam_mag = kwargs["inner_diam_mag"]
        self.mag_moment = kwargs["mag_moment"]

        self.dt = args[0].dt.value
        self.time_start_sim = rospy.get_time()
        self.time = 0.
        self.time_sim = 0
        # self.mag_moment = [0.003, 0.002, 0.002]
        self.b_field = [0.08, 0., 0.]
        self.speed = 0.
        self.length = 0.
        self.length_des = 0.
        self.currents = [0., 0., 0.]
        self.adv_speed = 0.
        self.tip_pose = [0., 0., 0., 0., 0., 0., 1.]

        # Navion load calibration
        if not rospy.has_param('~cal_path'):
            rp = rospkg.RosPack()
            cal_path = os.path.join(
                rp.get_path('mpem'),
                'cal',
                'Navion_2_Calibration_24-02-2020.yaml')
            rospy.logwarn(
                'Calibration path not specified, defaulting to %s',
                cal_path)
        else:
            cal_path = rospy.get_param('~cal_path')
        self.forward_model = mag_manip.ForwardModelMPEM()
        self.forward_model.setCalibrationFile(cal_path)

        #  ros subscribers
        self.ros_field_sub = rospy.Subscriber(
            "/mag_field",
            FieldStamped,
            self.ros_field_cb)
        self.ros_field_sub = rospy.Subscriber(
            "/navion/actual_currents",
            CurrentsStamped,
            self.ros_current_cb)
        self.ros_speed_sub = rospy.Subscriber(
            "/navion/actual_adv_speed",
            Float32,
            self.ros_adv_speed_cb)

        # ros publishers
        self.rod_pub = rospy.Publisher(
            '/rod_markers',
            MarkerArray,
            queue_size=1)
        self.pos_pub = rospy.Publisher(
            '/rod_sim_insertion_length',
            Float32, queue_size=1)
        self.pose_tip_pub = rospy.Publisher(
            '/rod_sim_tip_pose',
            Pose, queue_size=1)          

    def ros_field_cb(self, msg):
        # subrcibe to ros topic and update magnetic field
        field_x = msg.field.vector.x
        field_y = msg.field.vector.y
        field_z = msg.field.vector.z
        # field_z = msg.field.vector.z
        self.b_field[0] = field_x
        self.b_field[1] = field_y
        self.b_field[2] = field_z

    def ros_current_cb(self, msg):
        self.currents = msg.currents

    def ros_adv_speed_cb(self, msg):
        self.adv_speed = msg.data

    def broadcast_transform(self):
        # broadcast transform between the simulation frame, the anatomical model and the mns
        br = tf.TransformBroadcaster()

        br.sendTransform((
            self.T_sim_mns[0],
            self.T_sim_mns[1],
            self.T_sim_mns[2]),
            (self.T_sim_mns[3],
             self.T_sim_mns[4],
             self.T_sim_mns[5],
             self.T_sim_mns[6]),
            rospy.Time.now(),
            "sofa_sim",
            "mns")

        br.sendTransform((
            self.T_2dmodel_sim[0],
            self.T_2dmodel_sim[1],
            self.T_2dmodel_sim[2]-0.005),
            (self.T_2dmodel_sim[3],
             self.T_2dmodel_sim[4],
             self.T_2dmodel_sim[5],
             self.T_2dmodel_sim[6]),
            rospy.Time.now(),
            "2d_model",
            "sofa_sim")

        br.sendTransform((
            self.tip_pose[0],
            self.tip_pose[1],
            self.tip_pose[2]),
            (self.tip_pose[3],
             self.tip_pose[4],
             self.tip_pose[5],
             self.tip_pose[6]),
            rospy.Time.now(),
            "rod_tip",
            "sofa_sim")

    def shut_down(self):
        rospy.loginfo('shutting down SOFA')
        os._exit(1)

    def currents_to_field(
            self,
            currents=np.array([0., 0., 0.]),
            position=np.array([0., 0., 0.]),
            inverted=False):

        bg_jac = self.forward_model.getFieldActuationMatrix(position)
        field = bg_jac.dot(currents)

        if inverted is True:
            field = -field

        return field

    def onAnimateBeginEvent(self, event):

        rospy.on_shutdown(self.shut_down)

        # Update time
        self.time_prev = self.time
        self.time = rospy.get_time()
        self.time_elapsed = self.time - self.time_start_sim

        self.time_sim = self.time_sim + self.dt

        num_nodes = len(self.MO.position)

        # Broadcast transforms
        self.broadcast_transform()

        speed_init = 0.02
        time_init = self.length_init/speed_init
        # during the first two seconds,
        # we put the catheter at its initial lenght
        if self.time_elapsed <= time_init:
            self.IRC.speed = speed_init
            return

        # self.IRC.xtip[:][4]=0.1

        # loop through magnets
        for i in range(0, len(self.mag_index)):

            # position and orientation of magnet    
            pos = self.MO.position[num_nodes-self.mag_index[i]-1]
            quat = [pos[3], pos[4], pos[5], pos[6]]

            r = R.from_quat(quat)
            X = r.apply([1., 0., 0.])

            # field at position of magnet
            actual_pos = np.array([pos[0], pos[1], pos[2]])
            actual_quat = np.array([quat[0], quat[1], quat[2], quat[3]])
            self.b_field = self.currents_to_field(
                self.currents,
                actual_pos,
                inverted=True)

            mag_field = Vec3(
                    self.b_field[0]*self.mag_moment[i],
                    self.b_field[1]*self.mag_moment[i],
                    self.b_field[2]*self.mag_moment[i])

            # torque on magnet
            T = Vec3()
            T = T.cross(X, mag_field)
            # Update forces
            self.CFF.forces[i][:] = [0., 0., 0., T[0], T[1], T[2]]

        # update catheter speed
        if self.length_des == self.length:
            self.speed = 0.
        elif self.length_des > self.length:
            self.speed = 0.02
        elif self.length_des < self.length:
            self.speed = -0.02
        self.length = self.length_des

        # field arrow visualization
        self.CFF_visu.force = [
            mag_field[0], mag_field[1], mag_field[2], 0, 0, 0]

        speed_sim = self.adv_speed*1e-3 * (self.time-self.time_prev)/self.dt
        self.IRC.speed = speed_sim

        # impose magnet rigid tube position with respect to distal end of instrument
        # tube_rig_0
        self.IRC.xtip[:][1] = self.IRC.xtip[:][0]-self.tube_rig_pos[0]
        # tube_rig_1
        self.IRC.xtip[:][2] = self.IRC.xtip[:][0]-self.tube_rig_pos[1]
        # tube_rig_2
        self.IRC.xtip[:][3] = self.IRC.xtip[:][0]-self.tube_rig_pos[2]
        # Publish beam markers for rviz display
        rod_msg = getBeamMarkers(
            self.MO_visu_rviz,
            beam_rad = self.outer_diam_tube/2,
            beam_opacity = 1.,
            beam_color = [0.2, .8, 1.],
            magnet_rad = self.outer_diam_mag/2,
            magnet_opacity = 1.,
            magnet_color = [0.4, 0.4, 0.4],
            magnets_indices = self.mag_index_visu,
            magnet_length = self.mag_len[1],
            t=self.time)
        self.rod_pub.publish(rod_msg)

        # Publish insertion length
        pos_msg = Float32()
        pos_msg.data = (self.IRC.xtip[:][0] - self.length_init) * 1000.
        self.pos_pub.publish(pos_msg)

        # Publish tip pose
        self.tip_pose = self.MO.position[num_nodes-1]

        tip_pose_msg = Pose()
        tip_pose_msg.position.x = self.tip_pose[0]
        tip_pose_msg.position.y = self.tip_pose[1]
        tip_pose_msg.position.z = self.tip_pose[2]
        tip_pose_msg.orientation.x = self.tip_pose[3]
        tip_pose_msg.orientation.y = self.tip_pose[4]
        tip_pose_msg.orientation.z = self.tip_pose[5]
        tip_pose_msg.orientation.w = self.tip_pose[6]
        self.pose_tip_pub.publish(tip_pose_msg)
        
        # print(self.MO.constraint.value)
   
        return 0


def createScene(rootNode):

    sheath_sim_pos = rospy.get_param('sheath_sim_pos', [-0.005, -0.085, 0.0])
    sheath_sim_rot = rospy.get_param('sheath_sim_rot', [90.0, 0.0, 0.0])  # rpy angles (deg)
    model_mesh_path = rospy.get_param('model_mesh_path', '/mesh/2d_model_circles.stl')
    model_sim_pos = rospy.get_param('model_sim_pos', [0.001, -0.0005, -0.002])
    model_sim_rot = rospy.get_param('model_sim_rot', [0.0, 0.0, 89.5])  # rpy angles (deg)
    length_init = rospy.get_param('length_init', 0.145)
    lcp_solv_mu = rospy.get_param('lcp_solv_mu', 1e-2)
    
    # translation from sheath tip to insertion point of instrument
    transl_instr_sheath = [-0.0,  -0.0, 0.14]

    # rotation matrix from euler
    r = R.from_euler('xyz', sheath_sim_rot, degrees=True)
    rot_matrix =r.as_dcm()

    # transform sofa frame of ref to sheath
    T_sheath_sim = np.eye(4)
    T_sheath_sim[0:3, 0:3] = rot_matrix
    T_sheath_sim[0,3] = sheath_sim_pos[0]
    T_sheath_sim[1,3] = sheath_sim_pos[1]
    T_sheath_sim[2,3] = sheath_sim_pos[2]

    # transform sheath to insertion point of instrument
    T_insert_sheath = np.eye(4)
    T_insert_sheath[3,3] =1.
    T_insert_sheath[3,3] =1.
    T_insert_sheath[3,3] =1.
    T_insert_sheath[0,3] = transl_instr_sheath[0]
    T_insert_sheath[1,3] = transl_instr_sheath[1]
    T_insert_sheath[2,3] = transl_instr_sheath[2]
    T_insert_sim = np.matmul(T_sheath_sim, T_insert_sheath)

    start_insert_orient = [
        sheath_sim_rot[0],
        sheath_sim_rot[1],
        sheath_sim_rot[2] + 90.]
    trans_insert_sim = T_insert_sim[0:3, 3]

    start_insert_quat = Quat.createFromEuler([
        start_insert_orient[0]*np.pi/180,
        start_insert_orient[1]*np.pi/180,
        start_insert_orient[2]*np.pi/180])

    starting_position = [
        trans_insert_sim[0],
        trans_insert_sim[1],
        trans_insert_sim[2],                                                                                                                                                                                                                                                                                                                                                            
        start_insert_quat[0],
        start_insert_quat[1],
        start_insert_quat[2],
        start_insert_quat[3]]

    num_beams_body = 60
    num_beams_tip = 7
    num_edge_visu = 200
    YoungModulus = 40e6
    outer_diam_tube = 0.0009
    inner_diam_tube = 0.0007
    outer_diam_mag = 0.0015
    inner_diam_mag = 0.0008
    
    mag_len = [0.015, 0.01, 0.01]
    tube_rig_len = mag_len
    tube_rig_pos = [0., 0.04, 0.07]  # positioning of magnet rigid tubes away from tip
    instr_len_tot = 0.8
    instr_len_tip = 0.11
    instr_len_body = instr_len_tot-instr_len_tip

    # index of the magnets counting from tip
    mag_index = [0, 2, 4]
    # index of the magnets for visual object
    mag_index_visu = [
        int(num_edge_visu*(instr_len_tot-tube_rig_pos[0])-1),
        int(num_edge_visu*(instr_len_tot-tube_rig_pos[0])-2),
        int(num_edge_visu*(instr_len_tot-tube_rig_pos[1])-2),
        int(num_edge_visu*(instr_len_tot-tube_rig_pos[2])-2)]

    # # Seems like the inner diameter of the beam is not accounted for to compute the stiffness: 
    # # compute the outer diameter of a plain circular section with equivalent moment of area
    outer_diam_eq = ((outer_diam_tube/2.)**4.-(inner_diam_tube/2.)**4.)**(1./4.)
    Lm = 10e-3        # length (m)
    Br = 1.45        # remanent field (T)

    V = Lm*math.pi*((outer_diam_mag/2.)**2-(inner_diam_mag/2.)**2.)  # volume
    mu0 = (4.*math.pi)*1e-7
    magnet_mom = (1./mu0)*Br*V  # dipole moment
    magnet_mom = magnet_mom/10
    mag_moment = [magnet_mom*3, magnet_mom*2, magnet_mom*2]

    rootNode.animate = True
    rootNode.dt = 0.02
    rootNode.gravity = [0, 0, 0]

    # anatomical model to sofa sim frame of reference
    # convert euler to quat                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
    quat_model_sim = Quat.createFromEuler([
        model_sim_rot[0]*np.pi/180,
        model_sim_rot[1]*np.pi/180,
        model_sim_rot[2]*np.pi/180])
    T_2dmodel_sim = [
        model_sim_pos[0],
        model_sim_pos[1],
        model_sim_pos[2],
        quat_model_sim[0],
        quat_model_sim[1],
        quat_model_sim[2],
        quat_model_sim[3]]

    # sofa sim frame of refernce to mns
    transl_sim_mns = [0, 0, 0]
    T_sim_mns = [
        transl_sim_mns[0],
        transl_sim_mns[1],
        transl_sim_mns[2],
        0, 0, 0, 1]


    rootNode.addObject(
        'RequiredPlugin', name='ImportSoftRob', pluginName='SoftRobots')
    rootNode.addObject(
        'RequiredPlugin', name='ImportBeamAdapt', pluginName='BeamAdapter')
    rootNode.addObject(
        'RequiredPlugin', name='ImportSofaPython3', pluginName='SofaPython3')

    rootNode.addObject(
        'VisualStyle',
        displayFlags='showVisualModels hideBehaviorModels hideCollisionModels hideMappings hideForceFields hideInteractionForceFields')
    rootNode.addObject(
        'FreeMotionAnimationLoop')
    rootNode.addObject(
        'LCPConstraintSolver',
        mu=lcp_solv_mu,
        tolerance='1e-6',
        maxIt='10000',
        build_lcp='false')
    rootNode.addObject(
        'CollisionPipeline',
        draw='0',
        depth='6',
        verbose='1')
    # rootNode.addObject('BruteForceBroadPhase')
    # rootNode.addObject('BVHNarrowPhase')
    rootNode.addObject(
        'BruteForceDetection',
        name='N2')
    rootNode.addObject(
        'LocalMinDistance',
        contactDistance='0.001',
        alarmDistance='0.004',
        name='localmindistance',
        angleCone='0.02')
    rootNode.addObject(
        'CollisionResponse',
        name='Response', 
        response='FrictionContact')
    rootNode.addObject(
        'CollisionGroup',
        name='Group')
    rootNode.addObject(
        'OglSceneFrame',
        style='Arrows',
        alignment='TopRight')
    
    ################
    
    # wire rest shape
    # tube 0
    tube_0 = rootNode.addChild('tube_0')
    tube_0.addObject(
        'WireRestShape',
        name='GuideRestShape',
        straightLength=instr_len_tot-instr_len_tip,
        length=instr_len_tot,
        numEdges=num_edge_visu,
        youngModulus=YoungModulus*15,
        spireDiameter=250.0,
        numEdgesCollis=[num_beams_body, num_beams_tip],
        printLog=True,
        template='Rigid3d',
        spireHeight=0.0,
        radius=outer_diam_tube/2.0,
        radiusExtremity=outer_diam_tube/2.0,
        densityOfBeams=[num_beams_body, num_beams_tip],
        youngModulusExtremity=YoungModulus)
    tube_0.addObject('EdgeSetTopologyContainer', name='meshLinesGuide')
    tube_0.addObject('EdgeSetTopologyModifier', name='Modifier')
    tube_0.addObject(
        'EdgeSetGeometryAlgorithms', name='GeomAlgo', template='Rigid3d')
    tube_0.addObject(
        'MechanicalObject', name='dofTopo2', template='Rigid3d')

    # rigid tube 0
    tube_rig_0 = rootNode.addChild('tube_rig_0')
    tube_rig_0.addObject(
        'WireRestShape',
        name='GuideRestShape',
        straightLength=instr_len_tot-tube_rig_len[0],  # distance of distal end of rigid tube measured from distal end of instrument
        length=instr_len_tot,
        numEdges=num_edge_visu,
        youngModulus=1.,  # straight segment is "infinitally" flexible, the straight part serves as a placeholder for the rigid tip
        spireDiameter=250.0,
        numEdgesCollis=[num_beams_body, num_beams_tip],
        printLog=True,
        template='Rigid3d',
        spireHeight=0.0,
        radius=outer_diam_tube/2.0,
        radiusExtremity=outer_diam_tube/2.0,
        densityOfBeams=[num_beams_body, num_beams_tip],
        youngModulusExtremity=1e12)  # tip is infinitelly stiff
    tube_rig_0.addObject('EdgeSetTopologyContainer', name='meshLinesGuide')
    tube_rig_0.addObject('EdgeSetTopologyModifier', name='Modifier')
    tube_rig_0.addObject(
        'EdgeSetGeometryAlgorithms', name='GeomAlgo', template='Rigid3d')
    tube_rig_0.addObject(
        'MechanicalObject', name='dofTopo2', template='Rigid3d')

    # rigid tube 1
    tube_rig_1 = rootNode.addChild('tube_rig_1')
    tube_rig_1.addObject(
        'WireRestShape',
        name='GuideRestShape',
        straightLength=instr_len_tot-tube_rig_len[1],  # distance of distal end of rigid tube away from distal end of instrument
        length=instr_len_tot,
        numEdges=num_edge_visu,
        youngModulus=1.,  # straight segment is "infinitally" flexible, the straight part serves as a placeholder for the rigid tip
        spireDiameter=250.0,
        numEdgesCollis=[num_beams_body, num_beams_tip],
        printLog=True,
        template='Rigid3d',
        spireHeight=0.0,
        radius=outer_diam_tube/2.0,
        radiusExtremity=outer_diam_tube/2.0,
        densityOfBeams=[num_beams_body, num_beams_tip],
        youngModulusExtremity=1e12)  # tip is infinitelly stiff
    tube_rig_1.addObject('EdgeSetTopologyContainer', name='meshLinesGuide')
    tube_rig_1.addObject('EdgeSetTopologyModifier', name='Modifier')
    tube_rig_1.addObject(
        'EdgeSetGeometryAlgorithms', name='GeomAlgo', template='Rigid3d')
    tube_rig_1.addObject(
        'MechanicalObject', name='dofTopo2', template='Rigid3d')
    
    # rigid tube 2
    tube_rig_2 = rootNode.addChild('tube_rig_2')
    tube_rig_2.addObject(
        'WireRestShape',
        name='GuideRestShape',
        straightLength=instr_len_tot-tube_rig_len[2],  # distance of distal end of rigid tube away from distal end of instrument
        length=instr_len_tot,
        numEdges=num_edge_visu,
        youngModulus=1.,  # straight segment is "infinitally" flexible, the straight part serves as a placeholder for the rigid tip
        spireDiameter=250.0,
        numEdgesCollis=[num_beams_body, num_beams_tip],
        printLog=True,
        template='Rigid3d',
        spireHeight=0.0,
        radius=outer_diam_tube/2.0,
        radiusExtremity=outer_diam_tube/2.0,
        densityOfBeams=[num_beams_body, num_beams_tip],
        youngModulusExtremity=1e12)  # tip is infinitelly stiff
    tube_rig_2.addObject('EdgeSetTopologyContainer', name='meshLinesGuide')
    tube_rig_2.addObject('EdgeSetTopologyModifier', name='Modifier')
    tube_rig_2.addObject(
        'EdgeSetGeometryAlgorithms', name='GeomAlgo', template='Rigid3d')
    tube_rig_2.addObject(
        'MechanicalObject', name='dofTopo2', template='Rigid3d')

    InstrumentCombined = rootNode.addChild('InstrumentCombined')
    InstrumentCombined.addObject(
        'EulerImplicit',
        rayleighStiffness=0.2,
        printLog=False,
        rayleighMass=0.0)
    InstrumentCombined.addObject(
        'BTDLinearSolver',
        verification=False,
        subpartSolve=False,
        verbose=False)
    RG = InstrumentCombined.addObject(
        'RegularGrid',
        name='meshLinesCombined',
        zmax=1, zmin=1, nx=(num_beams_body+num_beams_tip),
        ny=1, nz=1, xmax=0.2, xmin=0.0, ymin=0, ymax=0)
    MO = InstrumentCombined.addObject(
        'MechanicalObject',
        showIndices=False,
        name='DOFs',
        template='Rigid3d',
        translation=[-0.10, 0., 0.])

    MO.init()


    restPos = []
    indicesAll = []
    i = 0
    for pos in MO.rest_position.value:
        restPos.append(starting_position)
        indicesAll.append(i)
        i = i+1

    MO.rest_position.value = restPos

    # interpolations
    # tube 0
    InstrumentCombined.addObject(
        'WireBeamInterpolation',
        WireRestShape='@../tube_0/GuideRestShape',
        radius=outer_diam_tube/2.0, printLog=True, name='InterpolTube0')

    InstrumentCombined.addObject(
        'AdaptiveBeamForceFieldAndMass', massDensity=155.0,
        name='TubeForceField0', interpolation='@InterpolTube0')
    # rigid tube 0
    InstrumentCombined.addObject(
        'WireBeamInterpolation',
        WireRestShape='@../tube_rig_0/GuideRestShape',
        radius=outer_diam_tube/2.0, printLog=True, name='InterpolRig0')
    InstrumentCombined.addObject(
        'AdaptiveBeamForceFieldAndMass', massDensity=155.0,
        name='TubeRigForceField0', interpolation='@InterpolRig0')
    # rigid tube 1
    InstrumentCombined.addObject(
        'WireBeamInterpolation',
        WireRestShape='@../tube_rig_1/GuideRestShape',
        radius=outer_diam_tube/2.0, printLog=True, name='InterpolRig1')
    InstrumentCombined.addObject(
        'AdaptiveBeamForceFieldAndMass', massDensity=155.0,
        name='TubeRigForceField1', interpolation='@InterpolRig1')
    # rigid tube 2
    InstrumentCombined.addObject(
        'WireBeamInterpolation',
        WireRestShape='@../tube_rig_2/GuideRestShape',
        radius=outer_diam_tube/2.0, printLog=True, name='InterpolRig2')
    InstrumentCombined.addObject(
        'AdaptiveBeamForceFieldAndMass', massDensity=155.0,
        name='TubeRigForceField2', interpolation='@InterpolRig2')

    IIR = InstrumentCombined.addObject(
        'InterventionalRadiologyController',
        xtip=[0.001, 0, 0],
        name='m_ircontroller',
        instruments='InterpolTube0 InterpolRig0 InterpolRig1 InterpolRig2',
        step=0.0007,
        printLog=True, listening=True, template='Rigid3d',
        startingPos=[0, 0, 0, 0, 0, 0, 1], mainDirection=[1, 0, 0],
        rotationInstrument=[0, 0, 0], speed=0.005, controlledInstrument=0)
    InstrumentCombined.addObject(
        'LinearSolverConstraintCorrection',
        wire_optimization='true',
        printLog=False)
    InstrumentCombined.addObject(
        'FixedConstraint',
        indices=0,
        name='FixedConstraint')
    InstrumentCombined.addObject(
        'RestShapeSpringsForceField',
        points='@m_ircontroller.indexFirstNode',
        angularStiffness=1e8,
        stiffness=1e8)

    CFF=InstrumentCombined.addObject(
        'ConstantForceField',
        name='CFF',
        indices=mag_index,
        force='0 0 0 0 0 0',
        indexFromEnd=True)

    CFF_visu=InstrumentCombined.addObject(
        'ConstantForceField',
        name='CFF_visu',
        indices=0,
        force='0 0 0 0 0 0',
        showArrowSize=200)

    InstrumentCombined.addObject(
        'PartialFixedConstraint',
        indices=indicesAll,
        fixedDirections='0 0 1 0 0 0',
        fixAll=True)

    # # VISU

    CathVisu = InstrumentCombined.addChild('CathVisu0')
    CathVisu.addObject('MechanicalObject', name='QuadsCatheter')
    CathVisu.addObject('QuadSetTopologyContainer', name='ContainerCath')
    CathVisu.addObject('QuadSetTopologyModifier', name='Modifier')
    CathVisu.addObject( 'QuadSetGeometryAlgorithms', name='GeomAlgo', 
                                    template='Vec3d')
    CathVisu.addObject('Edge2QuadTopologicalMapping', flipNormals= 'true', 
                                    input= '@../../tube_0/meshLinesGuide', 
                                    nbPointsOnEachCircle= '10', 
                                    output= '@ContainerCath', 
                                    radius= outer_diam_tube/2, 
                                    tags= 'catheter')
    CathVisu.addObject('AdaptiveBeamMapping', interpolation= '@../InterpolTube0', 
                                    input= '@../DOFs', 
                                    isMechanical= 'false', 
                                    name= 'VisuMapCath', 
                                    output= '@QuadsCatheter', 
                                    printLog= '1', 
                                    useCurvAbs= '1')
    VisuOgl = CathVisu.addChild('VisuOgl')
    VisuOgl.addObject('OglModel', quads='@../ContainerCath.quads', 
                                    color='0 0.85 0.9', 
                                    material='texture Ambient 1 0.2 0.2 0.2 0.0 Diffuse 1 1.0 1.0 1.0 1.0 Specular 1 1.0 1.0 1.0 1.0 Emissive 0 0.15 0.05 0.05 0.0 Shininess 1 20', 
                                    name='VisualCatheter')
    VisuOgl.addObject('IdentityMapping',input='@../QuadsCatheter', 
                                    output='@VisualCatheter', 
                                    name='VisuCathIM')

    CathVisu = InstrumentCombined.addChild('CathVisu0')
    CathVisu.addObject('MechanicalObject', name='QuadsCatheter')
    CathVisu.addObject('QuadSetTopologyContainer', name='ContainerCath')
    CathVisu.addObject('QuadSetTopologyModifier', name='Modifier')
    CathVisu.addObject( 'QuadSetGeometryAlgorithms', name='GeomAlgo', 
                                    template='Vec3d')
    CathVisu.addObject('Edge2QuadTopologicalMapping', flipNormals= 'true', 
                                    input= '@../../tube_rig_1/meshLinesGuide', 
                                    nbPointsOnEachCircle= '10', 
                                    output= '@ContainerCath', 
                                    radius= outer_diam_tube/2*1.01, 
                                    tags= 'catheter')
    CathVisu.addObject('AdaptiveBeamMapping', interpolation= '@../InterpolRig1', 
                                    input= '@../DOFs', 
                                    isMechanical= 'false', 
                                    name= 'VisuMapCath', 
                                    output= '@QuadsCatheter', 
                                    printLog= '1', 
                                    useCurvAbs= '1')
    VisuOgl = CathVisu.addChild('VisuOgl')
    VisuOgl.addObject('OglModel', quads='@../ContainerCath.quads', 
                                    color='0 0 1', 
                                    material='texture Ambient 1 0.2 0.2 0.2 0.0 Diffuse 1 1.0 1.0 1.0 1.0 Specular 1 1.0 1.0 1.0 1.0 Emissive 0 0.15 0.05 0.05 0.0 Shininess 1 20', 
                                    name='VisualCatheter')
    VisuOgl.addObject('IdentityMapping',input='@../QuadsCatheter', 
                                    output='@VisualCatheter', 
                                    name='VisuCathIM')

    CathVisu = InstrumentCombined.addChild('CathVisu0')
    CathVisu.addObject('MechanicalObject', name='QuadsCatheter')
    CathVisu.addObject('QuadSetTopologyContainer', name='ContainerCath')
    CathVisu.addObject('QuadSetTopologyModifier', name='Modifier')
    CathVisu.addObject( 'QuadSetGeometryAlgorithms', name='GeomAlgo', 
                                    template='Vec3d')
    CathVisu.addObject('Edge2QuadTopologicalMapping', flipNormals= 'true', 
                                    input= '@../../tube_rig_2/meshLinesGuide', 
                                    nbPointsOnEachCircle= '10', 
                                    output= '@ContainerCath', 
                                    radius= outer_diam_tube/2*1.02, 
                                    tags= 'catheter')
    CathVisu.addObject('AdaptiveBeamMapping', interpolation= '@../InterpolRig2', 
                                    input= '@../DOFs', 
                                    isMechanical= 'false', 
                                    name= 'VisuMapCath', 
                                    output= '@QuadsCatheter', 
                                    printLog= '1', 
                                    useCurvAbs= '1')
    VisuOgl = CathVisu.addChild('VisuOgl')
    VisuOgl.addObject('OglModel', quads='@../ContainerCath.quads', 
                                    color='0 1 0', 
                                    material='texture Ambient 1 0.2 0.2 0.2 0.0 Diffuse 1 1.0 1.0 1.0 1.0 Specular 1 1.0 1.0 1.0 1.0 Emissive 0 0.15 0.05 0.05 0.0 Shininess 1 20', 
                                    name='VisualCatheter')
    VisuOgl.addObject('IdentityMapping',input='@../QuadsCatheter', 
                                    output='@VisualCatheter', 
                                    name='VisuCathIM')

    # # COLLISION
    # instruments
    Collis = InstrumentCombined.addChild('Collis')
    Collis.activated = True
    Collis.addObject(
        'EdgeSetTopologyContainer',
        name='collisEdgeSet')
    Collis.addObject(
        'EdgeSetTopologyModifier',
        name='colliseEdgeModifier')
    Collis.addObject(
        'MechanicalObject',
        name='CollisionDOFs')
    Collis.addObject(
        'MultiAdaptiveBeamMapping',
        controller='../m_ircontroller', 
        useCurvAbs=True, 
        printLog=False, 
        name='collisMap')
    Collis.addObject(
        'LineCollisionModel',
        proximity=0.0, 
        group=1)
    Collis.addObject(
        'PointCollisionModel',
        proximity=0.0, 
        group=1)

    # # COLLISION ENVIRONMENT
    # 2d model
    CollisionModel = rootNode.addChild('CollisionModel')
    CollisionModel.addObject(
        'MeshSTLLoader',
        filename='..'+model_mesh_path,
        flipNormals=False,
        triangulate=True,
        name='meshLoader',
        translation=model_sim_pos,
        rotation=model_sim_rot,
        scale='0.001')
    CollisionModel.addObject(
        'Mesh', position='@meshLoader.position', 
        triangles='@meshLoader.triangles', 
        drawTriangles='0')
    CollisionModel.addObject(
        'MechanicalObject', position=[0,0,0], 
        scale=1, 
        name='DOFs1')

    CollisionModel.addObject(
        'TriangleCollisionModel',
        moving=False, 
        simulated=False)
    CollisionModel.addObject(
        'LineCollisionModel',
        moving=False, 
        simulated=False)
    CollisionModel.addObject(
        'PointCollisionModel',
        moving=False, 
        simulated=False)

    # introducer sheath
    CollisionModel_2 = rootNode.addChild('CollisionModel_2')
    CollisionModel_2.addObject(
        'MeshSTLLoader',
        filename='../mesh/sofa_introducer_sheath_id3mm_L75mm.stl',
        flipNormals=False,
        triangulate=True,
        name='meshLoader',
        translation=sheath_sim_pos,
        rotation=sheath_sim_rot,
        scale='0.001')
    CollisionModel_2.addObject(
        'Mesh', position='@meshLoader.position', 
        triangles='@meshLoader.triangles', 
        drawTriangles='0')
    CollisionModel_2.addObject(
        'MechanicalObject', position=[0,0,0], 
        scale=1, 
        name='DOFs1')

    CollisionModel_2.addObject(
        'TriangleCollisionModel',
        moving=False, 
        simulated=False)
    CollisionModel_2.addObject('LineCollisionModel', moving=False, 
                                    simulated=False)
    CollisionModel_2.addObject('PointCollisionModel', moving=False, 
                                    simulated=False)

    # # VISU MODEL

    VisuModel = CollisionModel.addChild('VisuModel')
    VisuModel.addObject('OglModel', name="VisualOgl_model", 
                                    src='@../meshLoader', 
                                    color='0.77 0.81  0.8')

    rootNode.addObject('BackgroundSetting', color='1 1 1')

    VisuModel_2 = CollisionModel_2.addChild('VisuModel_2')
    VisuModel_2.addObject('OglModel', name="VisualOgl_model", 
                                    src='@../meshLoader', 
                                    color='0.77 0.81  0.8')

    rootNode.addObject('BackgroundSetting', color='1 1 1')

    # VISU Rviz

    CathVisuROS = InstrumentCombined.addChild(
        'CathVisuROS')
    CathVisuROS.addObject(
        'RegularGrid',
        name='meshLinesCombined',
        zmax=0., zmin=0., nx=num_edge_visu, ny=1, nz=1,
        xmax=1., xmin=0.0, ymin=0.0, ymax=0.0)
    MO_visu_rviz = CathVisuROS.addObject(
        'MechanicalObject',
        name='ROSCatheterVisu',
        template='Rigid3d')
    CathVisuROS.addObject(
        'AdaptiveBeamMapping',
        interpolation='@../InterpolRviz',
        printLog='1',
        useCurvAbs='1')

    # Add our python controller in the scene
    rootNode.addObject(CatheterControl(
        rootNode,
        MechObj=MO,
        InterventionalRadiologyController=IIR,
        ConstantForceField=CFF,
        CCF_visu_mag_field=CFF_visu,
        mag_index=mag_index,
        mag_moment=mag_moment,
        length_init=length_init,
        tube_rig_pos=tube_rig_pos,
        T_sim_mns=T_sim_mns,
        T_2dmodel_sim=T_2dmodel_sim,
        outer_diam_tube=outer_diam_tube,
        inner_diam_tube=inner_diam_tube,
        outer_diam_mag= outer_diam_mag,
        inner_diam_mag = inner_diam_mag,
        MO_visu_rviz=MO_visu_rviz,
        mag_index_visu = mag_index_visu,
        mag_len=mag_len))