import Sofa
import numpy as np
from splib3.numerics import Quat, Vec3
import math
from scipy.spatial.transform import Rotation as R

from mag_manip import mag_manip

class CatheterControl(Sofa.Core.Controller):

    def __init__(self, *args, **kwargs):

        # These are needed (and the normal way to override from a python class)
        Sofa.Core.Controller.__init__(self, *args, **kwargs)

        self.dt = args[0].dt.value

        self.MO = kwargs["MechObj"]
        self.CFF = kwargs["ConstantForceField"]
        self.CFF_visu = kwargs["CCF_visu_mag_field"]
        self.IRC = kwargs["InterventionalRadiologyController"]
        self.mag_moment = kwargs["mag_moment"]
        self.lengthInit = kwargs["lengthinit"]
        self.indexMag = kwargs["indexMag"]
        self.indexMag_visu = kwargs["indexMag_visu"]
        # self.MO_visu = kwargs["MO_visu"]
        self.speed = kwargs["speed"]
        self.beamRad = kwargs["beamRad"]
        self.Tsofa_sim_mns = kwargs["Tsofa_sim_mns"]
        self.Taortic_arch_sofa_sim = kwargs["Taortic_arch_sofa_sim"]

        self.name = 'CatheterControl'

        self.BG = [0., 0., 0., 0., 0., 0., 0., 0.]
        self.field_0 = np.array([0., 0., 0.])
        self.Bangle = 30*3.14/180
        self.time = 0
        self.speed_des = 0.
        self.catheterLength = 0.

        self.numNodes = len(self.indexMag)

        self.time_simu = 0

        self.Bangle = 0.
        self.inclination_angle = 0
        self.azimuth_angle = 0

        cal_path = '../calib/Navion_2_Calibration_24-02-2020.yaml'
        self.forward_model = mag_manip.ForwardModelMPEM()
        self.forward_model.setCalibrationFile(cal_path)

        # Position of the entry point
        self.initPos = np.array([
            self.Tsofa_sim_mns[0],
            self.Tsofa_sim_mns[1],
            self.Tsofa_sim_mns[2]])  # coordinates of the sofa_sim frame center in Navion frame

    def currents_to_field(
            self,
            currents=np.array([0., 0., 0.]),
            position=np.array([0., 0., 0.]),
            inverted=False):

        bg_jac = self.forward_model.getFieldActuationMatrix(position)
        field = bg_jac.dot(currents)

        if inverted is True:
            field = -field

        return field

    def field_to_currents(
            self,
            field=np.array([0., 0., 0.]),
            position=np.array([0., 0., 0.])):

        bg_jac = self.forward_model.getFieldActuationMatrix(position)
        currents = np.linalg.inv(bg_jac).dot(field)

        return currents

    def onKeypressedEvent(self, event):

        # Increment field angle in rad
        dBangle=3.*3.14/180
        speed = 0.01

        key = event['key']
        # J key : inclination +
        if ord(key)==76:
            self.azimuth_angle-=dBangle
        # L key : inclination -
        if ord(key)==74:
            self.azimuth_angle+=dBangle
        # I key : azimuth +
        if ord(key)==73:
            self.inclination_angle-=dBangle
        # K key : azimuth -
        if ord(key)==75:
            self.inclination_angle+=dBangle

        return 0

    def onAnimateBeginEvent(self, event):

        for i in range(0, len(self.indexMag)):

            pos = self.MO.position[self.numNodes-self.indexMag[i]-1]
            quat = Quat(pos[3], pos[4], pos[5], pos[6])

            r = R.from_quat(quat)
            X = r.apply([1., 0., 0.])

            # Update magnetic model with new pose of catheters
            actual_pos = (
                np.array([
                    pos[0],
                    pos[1],
                    pos[2]]) +
                np.array([
                    self.Tsofa_sim_mns[0],
                    self.Tsofa_sim_mns[1],
                    self.Tsofa_sim_mns[2]]))  # pose of the tip in Navion frame

            self.currents = self.field_to_currents([0.02, 0., 0.])

            self.b_field = self.currents_to_field(
                self.currents,
                actual_pos,
                inverted=True)

            mag_field = Vec3(
                    self.b_field[0]*self.mag_moment,
                    self.b_field[1]*self.mag_moment,
                    self.b_field[2]*self.mag_moment)

            r = R.from_rotvec(self.inclination_angle * np.array([0, 1, 0]))
            mag_field = r.apply(mag_field)
            r = R.from_rotvec(self.azimuth_angle * np.array([0, 0, 1]))
            mag_field = r.apply(mag_field)

            # torque on magnet
            T = Vec3()
            T = T.cross(X, mag_field)
            # Update forces
            self.CFF.forces[i][:] = [0., 0., 0., T[0], T[1], T[2]]


        # field arrow visualization
        self.CFF_visu.force = [
            mag_field[0], mag_field[1], mag_field[2], 0, 0, 0]

        return 0


def createScene(rootNode):

    # UNITS: m, Pa, T

    # ### Parameters catheter ####

    YoungModulusBody = 170e6
    YoungModulusTip = 21e6
    LengthBody = 0.5
    LengthFlexibleTip = 0.034
    OuterDiam = 0.00133
    InnerDiam = 0.0008

    length_init = 0.3

    # ### Parameter magnet #######

    Lm = 4e-3        # length (m)
    dim = 0.86e-3   # inner diameter (m)
    dom = 1.33e-3   # outer diameter (m)
    Br = 1.45        # remanent field (T)

    # ########################################
    # Seems like the inner diameter of the beam is not accounted for to compute the stiffness: 
    # compute the outer diameter of a plain circular section with equivalent moment of area
    OuterDiamEq = ((OuterDiam/2.)**4.-(InnerDiam/2.)**4.)**(1./4.)

    V = Lm*math.pi*((dom/2.)**2-(dim/2.)**2.)  # volume
    mu0 = (4.*math.pi)*1e-7
    magnet_mom = (1./mu0)*Br*V  # dipole moment

    # ##### Transforms #############

    # ###### Sofa sim frame in Navion ##############

    # orientation is taken similar to the mns frame
    translationSimNavion = [0., -0.45, 0.]

    # ###### Model in sofa sim frame ##############

    rotationModelSim = [-90, 0, 0]  # rpy angles
    translationModelSim = [0, 0, 0]

    # Define frame transforms

    # convert euler to quat
    quatModelSim = Quat.createFromEuler([
        rotationModelSim[0]*math.pi/180,
        rotationModelSim[1]*math.pi/180,
        rotationModelSim[2]*math.pi/180])

    # transforms (translation , quat)
    Tsofa_sim_mns = [
        translationSimNavion[0],
        translationSimNavion[1],
        translationSimNavion[2],
        0., 0., 0., 1]
    Taortic_arch_sofa_sim = [
        translationModelSim[0],
        translationModelSim[1],
        translationModelSim[2],
        quatModelSim[0],
        quatModelSim[1],
        quatModelSim[2],
        quatModelSim[3]]

    # ## Define entry pose in model ###

    # starting pose in aortic arch frame
    startingPosition0 = [-.075, -.001, -.020, 0., -0.3826834, 0., 0.9238795]

    X = Vec3(
        startingPosition0[0],
        startingPosition0[1],
        startingPosition0[2])
    r = R.from_euler('xyz', rotationModelSim, degrees=True)
    X = r.apply(X)

    q = Quat.createFromEuler([
        rotationModelSim[0]*math.pi/180,
        rotationModelSim[1]*math.pi/180,
        rotationModelSim[2]*math.pi/180])
    qrot = Quat(
        startingPosition0[3],
        startingPosition0[4],
        startingPosition0[5],
        startingPosition0[6])
    q.rotateFromQuat(qrot)

    # starting pose sofa sim frame
    startingPosition = [
        X[0]+translationModelSim[0],
        X[1]+translationModelSim[1],
        X[2]+translationModelSim[2],
        q[0], q[1], q[2], q[3]]

    # ####### Parameter for beams ################

    numEdge = 200  # number of edges for visualization model
    numBeamsBody = 30  # number of beam elements on the body (for collision and physical model)
    numBeamsTip = 6  # number of beam elements on the tip (for collision and physical model)

    indexMag = np.array([0, numBeamsTip-1])  # index of the magnets (both ends of the flexible section)
    indexMag_visu = [
        int(numEdge*(LengthBody)),
        int(numEdge*(LengthBody+LengthFlexibleTip))]  # index of the magnets for visual object

    # #####################################

    rootNode.addObject(
        'RequiredPlugin', name='ImportSoftRob', pluginName='SoftRobots')
    rootNode.addObject(
        'RequiredPlugin', name='ImportBeamAdapt', pluginName='BeamAdapter')
    rootNode.addObject(
        'RequiredPlugin', name='ImportSofaPython3', pluginName='SofaPython3')

    rootNode.dt = 0.02
    rootNode.animate = True
    rootNode.gravity = [0, 0, 0]

    rootNode.addObject(
        'VisualStyle',
        displayFlags='showVisualModels hideBehaviorModels hideCollisionModels hideMappings hideForceFields hideInteractionForceFields')
    rootNode.addObject(
        'FreeMotionAnimationLoop')
    rootNode.addObject(
        'LCPConstraintSolver',
        mu='0.04',
        tolerance='1e-6',
        maxIt='10000',
        build_lcp='false')
    rootNode.addObject(
        'CollisionPipeline',
        draw='0',
        depth='6',
        verbose='1')
    rootNode.addObject(
        'BruteForceDetection',
        name='N2')
    rootNode.addObject(
        'LocalMinDistance',
        contactDistance='0.002',
        alarmDistance='0.003',
        name='localmindistance',
        angleCone='0.02')
    rootNode.addObject(
        'CollisionResponse',
        name='Response',
        response='FrictionContact')
    rootNode.addObject(
        'CollisionGroup',
        name='Group')

    ##############################

    topoLines_guide = rootNode.addChild('topoLines_guide')
    topoLines_guide.addObject(
        'WireRestShape',
        name='GuideRestShape',
        straightLength=LengthBody,
        length=LengthBody+LengthFlexibleTip,
        numEdges=numEdge,
        youngModulus=YoungModulusBody,
        spireDiameter=250.0,
        numEdgesCollis=[numBeamsBody, numBeamsTip],
        printLog=True,
        template='Rigid3d',
        spireHeight=0.0,
        radius=OuterDiamEq/2.0,
        radiusExtremity=OuterDiamEq/2.0,
        densityOfBeams=[numBeamsBody, numBeamsTip],
        youngModulusExtremity=YoungModulusTip)
    topoLines_guide.addObject(
        'EdgeSetTopologyContainer',
        name='meshLinesGuide')
    topoLines_guide.addObject(
        'EdgeSetTopologyModifier',
        name='Modifier')
    topoLines_guide.addObject(
        'EdgeSetGeometryAlgorithms',
        name='GeomAlgo',
        template='Rigid3d')
    topoLines_guide.addObject(
        'MechanicalObject',
        name='dofTopo2',
        template='Rigid3d')

    ###############################

    InstrumentCombined = rootNode.addChild('InstrumentCombined')
    InstrumentCombined.addObject(
        'EulerImplicit',
        rayleighStiffness=0.2,
        printLog=False,
        rayleighMass=0.0)
    InstrumentCombined.addObject(
        'BTDLinearSolver',
        verification=False,
        subpartSolve=False, verbose=False)
    RG = InstrumentCombined.addObject(
        'RegularGrid', name='meshLinesCombined',
        zmax=1, zmin=1,
        nx=numBeamsBody+numBeamsTip, ny=1, nz=1,
        xmax=0.2, xmin=0, ymin=0, ymax=0)
    MO = InstrumentCombined.addObject(
        'MechanicalObject', showIndices=False, name='DOFs', template='Rigid3d')

    MO.init()
    restPos = []
    indicesAll = []
    i = 0
    for pos in MO.rest_position.value:
        restPos.append(startingPosition)
        indicesAll.append(i)
        i = i+1

    forcesList = ""
    for i in range(0, len(indexMag)):
        forcesList += " 0 0 0 0 0 0 "

    indicesList = ''
    for i in range(0, len(indexMag)):
        indicesList += str(indexMag[i]) + ' '

    MO.rest_position.value = restPos

    InstrumentCombined.addObject(
        'WireBeamInterpolation',
        WireRestShape='@../topoLines_guide/GuideRestShape',
        radius=OuterDiamEq/2.0,
        printLog=True,
        name='InterpolGuide')
    InstrumentCombined.addObject(
        'AdaptiveBeamForceFieldAndMass',
        massDensity=155.0,
        name='GuideForceField',
        interpolation='@InterpolGuide')

    CFF = InstrumentCombined.addObject(
        'ConstantForceField',
        indices=indicesList,
        forces=forcesList,
        indexFromEnd=True)

    CFF_visu = InstrumentCombined.addObject(
        'ConstantForceField',
        name='CFF_visu',
        indices=0,
        force='0 0 0 0 0 0',
        indexFromEnd=True,
        showArrowSize=1000)

    IRC = InstrumentCombined.addObject(
        'InterventionalRadiologyController',
        xtip=[0.001], name='m_ircontroller',
        instruments='InterpolGuide',
        step=0.0007, printLog=True,
        listening=True,
        template='Rigid3d',
        startingPos=startingPosition,
        rotationInstrument=[0],
        speed=0.,
        mainDirection=[0, 0, 1],
        threshold=0.0005,
        controlledInstrument=0)
    InstrumentCombined.addObject(
        'LinearSolverConstraintCorrection',
        wire_optimization='true',
        printLog=False)
    InstrumentCombined.addObject(
        'FixedConstraint',
        indices=0,
        name='FixedConstraint')
    InstrumentCombined.addObject(
        'RestShapeSpringsForceField',
        points='@m_ircontroller.indexFirstNode',
        angularStiffness=1e8,
        stiffness=1e8)

    # visu 
    CathVisu = InstrumentCombined.addChild('CathVisu')
    CathVisu.addObject(
        'MechanicalObject',
        name='QuadsCatheter')
    CathVisu.addObject(
        'QuadSetTopologyContainer',
        name='ContainerCath')
    CathVisu.addObject(
        'QuadSetTopologyModifier',
        name='Modifier')
    CathVisu.addObject(
        'QuadSetGeometryAlgorithms',
        name='GeomAlgo',
        template='Vec3d')
    CathVisu.addObject(
        'Edge2QuadTopologicalMapping',
        flipNormals='true',
        input='@../../topoLines_guide/meshLinesGuide',
        nbPointsOnEachCircle='10',
        output='@ContainerCath',
        radius=OuterDiam/2,
        tags='catheter')
    CathVisu.addObject(
        'AdaptiveBeamMapping',
        interpolation='@../InterpolGuide',
        input='@../DOFs',
        isMechanical='false',
        name='VisuMapCath',
        output='@QuadsCatheter',
        printLog='1',
        useCurvAbs='1')

    VisuOgl = CathVisu.addChild('VisuOgl')
    VisuOgl.addObject(
        'OglModel',
        quads='@../ContainerCath.quads',
        color='0. 0. 1.',
        material='texture Ambient 1 0.2 0.2 0.2 0.0 Diffuse 1 1.0 1.0 1.0 1.0 Specular 1 1.0 1.0 1.0 1.0 Emissive 0 0.15 0.05 0.05 0.0 Shininess 1 20', name='VisualCatheter')
    VisuOgl.addObject(
        'IdentityMapping',
        input='@../QuadsCatheter',
        output='@VisualCatheter',
        name='VisuCathIM')

    # COLLISION MODEL FOR CATHETER

    Collis = InstrumentCombined.addChild('Collis')
    Collis.activated = True
    Collis.addObject(
        'EdgeSetTopologyContainer',
        name='collisEdgeSet')
    Collis.addObject(
        'EdgeSetTopologyModifier',
        name='colliseEdgeModifier')
    Collis.addObject(
        'MechanicalObject',
        name='CollisionDOFs')
    Collis.addObject(
        'MultiAdaptiveBeamMapping',
        controller='../m_ircontroller',
        useCurvAbs=True, printLog=False,
        name='collisMap')
    Collis.addObject(
        'LineCollisionModel',
        proximity=0.0,
        group=1)
    Collis.addObject(
        'PointCollisionModel',
        proximity=0.0,
        group=1)

    # COLLISION ENVIRONMENT

    CollisionModel = rootNode.addChild('CollisionModel')
    CollisionModel.addObject(
        'MeshObjLoader',
        filename='../mesh/anatomies/J2-Naviworks.obj',
        flipNormals=True,
        triangulate=True,
        name='meshLoader',
        scale3d='0.001 0.001 0.001',
        rotation=rotationModelSim,
        translation=translationModelSim)
    CollisionModel.addObject(
        'Mesh',
        position='@meshLoader.position',
        triangles='@meshLoader.triangles',
        drawTriangles='0')
    CollisionModel.addObject(
        'MechanicalObject',
        scale=1,
        name='DOFs1')
    CollisionModel.addObject(
        'TriangleCollisionModel',
        moving=False,
        simulated=False)
    CollisionModel.addObject(
        'LineCollisionModel',
        moving=False,
        simulated=False)
    CollisionModel.addObject(
        'PointCollisionModel',
        moving=False,
        simulated=False)

    # # VISU MODEL

    VisuModel = CollisionModel.addChild('VisuModel')
    VisuModel.addObject(
        'OglModel',
        name="VisualOgl_model",
        src='@../meshLoader',
        color='1. 0. 0. 0.3')

    rootNode.addObject('BackgroundSetting', color='1 1 1')

    # Add our python controller in the scene
    rootNode.addObject(CatheterControl(
        rootNode,
        MechObj=MO,
        InterventionalRadiologyController=IRC,
        ConstantForceField=CFF,
        CCF_visu_mag_field=CFF_visu,
        indexMag=indexMag,
        lengthinit=length_init,
        mag_moment=magnet_mom,
        speed=0.,
        indexMag_visu=indexMag_visu,
        # MO_visu=MO_visu,
        beamRad=OuterDiam/2,
        Tsofa_sim_mns=Tsofa_sim_mns,
        Taortic_arch_sofa_sim=Taortic_arch_sofa_sim))
